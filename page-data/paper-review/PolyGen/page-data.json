{"componentChunkName":"component---src-templates-paper-review-tsx","path":"/paper-review/PolyGen/","result":{"data":{"site":{"siteMetadata":{"title":"Azmarie Wang","author":"Azmarie Wang"}},"markdownRemark":{"id":"5914163b-65f7-55f6-94eb-1c7d04477e0c","excerpt":"Main Contribution The research problem in this paper is 3D object generation, specifically working with polygon meshes.  This research problem presents in…","html":"<h2 id=\"main-contribution\" style=\"position:relative;\"><a href=\"#main-contribution\" aria-label=\"main contribution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Main Contribution</h2>\n<p>The research problem in this paper is 3D object generation, specifically working with polygon meshes.  This research problem presents in creating a virtual world for AR/VR applications, games, and other virtual AI environments where objects are made out of 3D meshes. Mesh is known to be difficult to work with due to its unordered elements and discrete face structures, thus it’s often converted in a post-processing step from other representations. Inspired by successful neural autoregressive models on complex and high-dimensional data, the authors propose to use a neural generative model working directly with 3D meshes. </p>\n<p>The main contributions of this paper include the proposal of PolyGen, as a generative model of 3D objects which models the mesh directly, predicting vertices and faces sequentially using a Transformer-based architecture.</p>\n<h2 id=\"method\" style=\"position:relative;\"><a href=\"#method\" aria-label=\"method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method</h2>\n<p>As we know, a mesh consists of vertices and faces. In this model, two parts are proposed to tackle them individually, one is an autoregressive vertex model unconditionally modelling mesh vertices, and the other is an autoregressive face model modelling the mesh faces conditioned on input vertices. The model is trained on an augmented ShapeNet dataset and the renders of the processed ShapeNet meshes are created using Blender. </p>\n<p>Before the first model, there is a preprocessing step to convert the mesh to n-gon mesh from triangulated meshes in ShapeNet. N-gon meshes are meshes with variable length polygons. This is done to simplify the modelling task by reducing the size of meshes and removing the triangulation variability (polygons can be triangulated in different ways). Here, the authors address a limitation of n-gon that it doesn’t uniquely define a 3D surface with n≥3, which is minor here because most of the n-gons are or close to planars. </p>\n<p>Then for the two parts of models trained individually - to model vertices and then model the faces given the vertices. Firstly, the vertex model takes in a sequence of vertices, which are treated as a long sequence sorted by z,y,x axis values followed by a stopping token. Vertices are quantized into discrete variables and then modelled with categorical distribution, similar to PixelCNN and WaveNet. </p>\n<p>The authors mentioned a trade-off between <b>mesh fidelity and mesh size with the choice of bin numbers</b>, where a larger bin number is good for mesh compression but results in lossy quality. They find 8-bit quantization as a good balance. With the current sequence of vertex coordinates as context input, the autoregressive model outputs a predictive distribution for the next vertex coordinate, maximizing the log-probability of the sequence. Secondly, the face model takes in a sequence of mesh faces, ordered by their lowest vertex index, and second-lowest and so on. This is treated as a long sequence again with a new face token and stopping token. To condition on the input vertex set, the input is first embedded using an encoder to obtain contextual vertex embeddings, and then each of the input face sequences is embedded using the corresponding vertex embedding, and then Transformer decoder is used to output pointer at each step.</p>\n<p>The authors used the idea from the Pointer Network (replacing LSTM with Transformers) to compare the pointer vector with the input embeddings via a dot-product, then later normalized through softmax to obtain a distribution over the input set. The evaluation is conducted mainly through log-likelihood and other sanctity checks such as chamfer-distance and comparing generated sample distribution against real data. </p>\n<h2 id=\"whats-good-and-not-so-good\" style=\"position:relative;\"><a href=\"#whats-good-and-not-so-good\" aria-label=\"whats good and not so good permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What’s good and not so good?</h2>\n<p>The authors demonstrated that mesh generation with an autoregressive model working directly on mesh representation is doable. The novelty of this model is that it can directly model human-crafted mesh data, rather than alternative 3D representations in prior works. However, on the other hand, the mesh generation is conditioned on object representations such as images and voxels, which could still be limiting. </p>\n<p>Another limitation lies in the dataset available. As the authors marked in the paper, training only on the <b>ShapeNet dataset</b> will result in overfitting due to its relatively small size. Besides, the <b>Transformer model has high memory requirements</b>, which limits the training dataset to be within 800 vertices or 2800 face indices (exceeding meshes are filtered out), thus this model may <b>not be suited for large and complex meshes</b>. </p>\n<p>We have seen examples of taking a successful model from one domain and re-propose it to solve a problem from a different domain, for example, Mask-RCNN extends a successful network for object detection to instance segmentation, and then Mesh-RCNN into computer graphics. Once again, in this paper, <b>PolyGen makes use of Transformer for its success in NLP tasks and the capability to model complex data and turns into a high-performing 3D generation model</b>.</p>","fields":{"slug":"/PolyGen/"},"frontmatter":{"shortDate":"November 08, 2020","title":"PolyGen: An Autoregressive Generative Model of 3D Meshes","categories":["3D","Shape Generation"],"summaryType":"Paper Review","paperPDFLink":"https://arxiv.org/pdf/2002.10880.pdf","projectLink":"https://icml.cc/virtual/2020/poster/6851","projectTitle":"PolyGen","reference":"Nash, Charlie, Yaroslav Ganin, S. M. Eslami, and Peter W. Battaglia. \"PolyGen: An autoregressive generative model of 3D meshes.\" arXiv preprint arXiv:2002.10880 (2020).","published":true,"cover":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3FBmP//EABYQAAMAAAAAAAAAAAAAAAAAAAEQIP/aAAgBAQABBQJCP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABcQAQEBAQAAAAAAAAAAAAAAAAABEDH/2gAIAQEAAT8hqOF3/9oADAMBAAIAAwAAABCDz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAQADAAAAAAAAAAAAAAERADFBUXH/2gAIAQEAAT8Q6XzciUn0e66vvEOEwFkJgDhN/9k=","aspectRatio":1.910828025477707,"src":"/static/ccedd49b1dbd3850b92a827c0b4663c4/47498/teaser-optimized.jpg","srcSet":"/static/ccedd49b1dbd3850b92a827c0b4663c4/9dc27/teaser-optimized.jpg 300w,\n/static/ccedd49b1dbd3850b92a827c0b4663c4/4fe8c/teaser-optimized.jpg 600w,\n/static/ccedd49b1dbd3850b92a827c0b4663c4/47498/teaser-optimized.jpg 1200w,\n/static/ccedd49b1dbd3850b92a827c0b4663c4/d2909/teaser-optimized.jpg 1522w","sizes":"(max-width: 1200px) 100vw, 1200px"}}}}}},"pageContext":{"slug":"/PolyGen/"}},"staticQueryHashes":["63159454"]}